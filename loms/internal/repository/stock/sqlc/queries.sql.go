// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package sqlc

import (
	"context"
)

const getBySku = `-- name: GetBySku :one
SELECT sku, total_count FROM stock WHERE stock.sku = $1
`

func (q *Queries) GetBySku(ctx context.Context, stockSku int32) (Stock, error) {
	row := q.db.QueryRow(ctx, getBySku, stockSku)
	var i Stock
	err := row.Scan(&i.Sku, &i.TotalCount)
	return i, err
}

const getLockedBySku = `-- name: GetLockedBySku :one
SELECT sku, total_count FROM stock WHERE stock.sku = $1 FOR UPDATE OF stock
`

func (q *Queries) GetLockedBySku(ctx context.Context, stockSku int32) (Stock, error) {
	row := q.db.QueryRow(ctx, getLockedBySku, stockSku)
	var i Stock
	err := row.Scan(&i.Sku, &i.TotalCount)
	return i, err
}

const save = `-- name: Save :exec
INSERT INTO stock (sku, total_count) VALUES ($1, $2)
ON CONFLICT (sku) DO UPDATE SET total_count = excluded.total_count
`

type SaveParams struct {
	Sku        int32
	TotalCount int32
}

func (q *Queries) Save(ctx context.Context, arg SaveParams) error {
	_, err := q.db.Exec(ctx, save, arg.Sku, arg.TotalCount)
	return err
}
