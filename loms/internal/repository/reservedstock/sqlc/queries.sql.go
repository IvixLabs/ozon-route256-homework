// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package sqlc

import (
	"context"
)

const getLocked = `-- name: GetLocked :one
SELECT order_id, sku, count, status FROM "reserved_stock" WHERE order_id = $1 AND sku = $2 FOR UPDATE
`

type GetLockedParams struct {
	OrderID int32
	Sku     int32
}

func (q *Queries) GetLocked(ctx context.Context, arg GetLockedParams) (ReservedStock, error) {
	row := q.db.QueryRow(ctx, getLocked, arg.OrderID, arg.Sku)
	var i ReservedStock
	err := row.Scan(
		&i.OrderID,
		&i.Sku,
		&i.Count,
		&i.Status,
	)
	return i, err
}

const save = `-- name: Save :exec
INSERT INTO reserved_stock (order_id, sku, count, status)
VALUES ($1, $2, $3, $4)
ON CONFLICT (order_id, sku) DO UPDATE
  SET count = excluded.count, status = excluded.status
`

type SaveParams struct {
	OrderID int32
	Sku     int32
	Count   int32
	Status  string
}

func (q *Queries) Save(ctx context.Context, arg SaveParams) error {
	_, err := q.db.Exec(ctx, save,
		arg.OrderID,
		arg.Sku,
		arg.Count,
		arg.Status,
	)
	return err
}
