// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package mock

//go:generate minimock -i route256/loms/internal/usecase/order.StockService -o stock_service_mock.go -n StockServiceMock -p mock

import (
	"context"
	"route256/loms/internal/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StockServiceMock implements order.StockService
type StockServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCancelStocks          func(ctx context.Context, order model.Order) (err error)
	inspectFuncCancelStocks   func(ctx context.Context, order model.Order)
	afterCancelStocksCounter  uint64
	beforeCancelStocksCounter uint64
	CancelStocksMock          mStockServiceMockCancelStocks

	funcPayStocks          func(ctx context.Context, order model.Order) (err error)
	inspectFuncPayStocks   func(ctx context.Context, order model.Order)
	afterPayStocksCounter  uint64
	beforePayStocksCounter uint64
	PayStocksMock          mStockServiceMockPayStocks

	funcReserveStocks          func(ctx context.Context, order model.Order) (err error)
	inspectFuncReserveStocks   func(ctx context.Context, order model.Order)
	afterReserveStocksCounter  uint64
	beforeReserveStocksCounter uint64
	ReserveStocksMock          mStockServiceMockReserveStocks
}

// NewStockServiceMock returns a mock for order.StockService
func NewStockServiceMock(t minimock.Tester) *StockServiceMock {
	m := &StockServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelStocksMock = mStockServiceMockCancelStocks{mock: m}
	m.CancelStocksMock.callArgs = []*StockServiceMockCancelStocksParams{}

	m.PayStocksMock = mStockServiceMockPayStocks{mock: m}
	m.PayStocksMock.callArgs = []*StockServiceMockPayStocksParams{}

	m.ReserveStocksMock = mStockServiceMockReserveStocks{mock: m}
	m.ReserveStocksMock.callArgs = []*StockServiceMockReserveStocksParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStockServiceMockCancelStocks struct {
	optional           bool
	mock               *StockServiceMock
	defaultExpectation *StockServiceMockCancelStocksExpectation
	expectations       []*StockServiceMockCancelStocksExpectation

	callArgs []*StockServiceMockCancelStocksParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockServiceMockCancelStocksExpectation specifies expectation struct of the StockService.CancelStocks
type StockServiceMockCancelStocksExpectation struct {
	mock      *StockServiceMock
	params    *StockServiceMockCancelStocksParams
	paramPtrs *StockServiceMockCancelStocksParamPtrs
	results   *StockServiceMockCancelStocksResults
	Counter   uint64
}

// StockServiceMockCancelStocksParams contains parameters of the StockService.CancelStocks
type StockServiceMockCancelStocksParams struct {
	ctx   context.Context
	order model.Order
}

// StockServiceMockCancelStocksParamPtrs contains pointers to parameters of the StockService.CancelStocks
type StockServiceMockCancelStocksParamPtrs struct {
	ctx   *context.Context
	order *model.Order
}

// StockServiceMockCancelStocksResults contains results of the StockService.CancelStocks
type StockServiceMockCancelStocksResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCancelStocks *mStockServiceMockCancelStocks) Optional() *mStockServiceMockCancelStocks {
	mmCancelStocks.optional = true
	return mmCancelStocks
}

// Expect sets up expected params for StockService.CancelStocks
func (mmCancelStocks *mStockServiceMockCancelStocks) Expect(ctx context.Context, order model.Order) *mStockServiceMockCancelStocks {
	if mmCancelStocks.mock.funcCancelStocks != nil {
		mmCancelStocks.mock.t.Fatalf("StockServiceMock.CancelStocks mock is already set by Set")
	}

	if mmCancelStocks.defaultExpectation == nil {
		mmCancelStocks.defaultExpectation = &StockServiceMockCancelStocksExpectation{}
	}

	if mmCancelStocks.defaultExpectation.paramPtrs != nil {
		mmCancelStocks.mock.t.Fatalf("StockServiceMock.CancelStocks mock is already set by ExpectParams functions")
	}

	mmCancelStocks.defaultExpectation.params = &StockServiceMockCancelStocksParams{ctx, order}
	for _, e := range mmCancelStocks.expectations {
		if minimock.Equal(e.params, mmCancelStocks.defaultExpectation.params) {
			mmCancelStocks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCancelStocks.defaultExpectation.params)
		}
	}

	return mmCancelStocks
}

// ExpectCtxParam1 sets up expected param ctx for StockService.CancelStocks
func (mmCancelStocks *mStockServiceMockCancelStocks) ExpectCtxParam1(ctx context.Context) *mStockServiceMockCancelStocks {
	if mmCancelStocks.mock.funcCancelStocks != nil {
		mmCancelStocks.mock.t.Fatalf("StockServiceMock.CancelStocks mock is already set by Set")
	}

	if mmCancelStocks.defaultExpectation == nil {
		mmCancelStocks.defaultExpectation = &StockServiceMockCancelStocksExpectation{}
	}

	if mmCancelStocks.defaultExpectation.params != nil {
		mmCancelStocks.mock.t.Fatalf("StockServiceMock.CancelStocks mock is already set by Expect")
	}

	if mmCancelStocks.defaultExpectation.paramPtrs == nil {
		mmCancelStocks.defaultExpectation.paramPtrs = &StockServiceMockCancelStocksParamPtrs{}
	}
	mmCancelStocks.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCancelStocks
}

// ExpectOrderParam2 sets up expected param order for StockService.CancelStocks
func (mmCancelStocks *mStockServiceMockCancelStocks) ExpectOrderParam2(order model.Order) *mStockServiceMockCancelStocks {
	if mmCancelStocks.mock.funcCancelStocks != nil {
		mmCancelStocks.mock.t.Fatalf("StockServiceMock.CancelStocks mock is already set by Set")
	}

	if mmCancelStocks.defaultExpectation == nil {
		mmCancelStocks.defaultExpectation = &StockServiceMockCancelStocksExpectation{}
	}

	if mmCancelStocks.defaultExpectation.params != nil {
		mmCancelStocks.mock.t.Fatalf("StockServiceMock.CancelStocks mock is already set by Expect")
	}

	if mmCancelStocks.defaultExpectation.paramPtrs == nil {
		mmCancelStocks.defaultExpectation.paramPtrs = &StockServiceMockCancelStocksParamPtrs{}
	}
	mmCancelStocks.defaultExpectation.paramPtrs.order = &order

	return mmCancelStocks
}

// Inspect accepts an inspector function that has same arguments as the StockService.CancelStocks
func (mmCancelStocks *mStockServiceMockCancelStocks) Inspect(f func(ctx context.Context, order model.Order)) *mStockServiceMockCancelStocks {
	if mmCancelStocks.mock.inspectFuncCancelStocks != nil {
		mmCancelStocks.mock.t.Fatalf("Inspect function is already set for StockServiceMock.CancelStocks")
	}

	mmCancelStocks.mock.inspectFuncCancelStocks = f

	return mmCancelStocks
}

// Return sets up results that will be returned by StockService.CancelStocks
func (mmCancelStocks *mStockServiceMockCancelStocks) Return(err error) *StockServiceMock {
	if mmCancelStocks.mock.funcCancelStocks != nil {
		mmCancelStocks.mock.t.Fatalf("StockServiceMock.CancelStocks mock is already set by Set")
	}

	if mmCancelStocks.defaultExpectation == nil {
		mmCancelStocks.defaultExpectation = &StockServiceMockCancelStocksExpectation{mock: mmCancelStocks.mock}
	}
	mmCancelStocks.defaultExpectation.results = &StockServiceMockCancelStocksResults{err}
	return mmCancelStocks.mock
}

// Set uses given function f to mock the StockService.CancelStocks method
func (mmCancelStocks *mStockServiceMockCancelStocks) Set(f func(ctx context.Context, order model.Order) (err error)) *StockServiceMock {
	if mmCancelStocks.defaultExpectation != nil {
		mmCancelStocks.mock.t.Fatalf("Default expectation is already set for the StockService.CancelStocks method")
	}

	if len(mmCancelStocks.expectations) > 0 {
		mmCancelStocks.mock.t.Fatalf("Some expectations are already set for the StockService.CancelStocks method")
	}

	mmCancelStocks.mock.funcCancelStocks = f
	return mmCancelStocks.mock
}

// When sets expectation for the StockService.CancelStocks which will trigger the result defined by the following
// Then helper
func (mmCancelStocks *mStockServiceMockCancelStocks) When(ctx context.Context, order model.Order) *StockServiceMockCancelStocksExpectation {
	if mmCancelStocks.mock.funcCancelStocks != nil {
		mmCancelStocks.mock.t.Fatalf("StockServiceMock.CancelStocks mock is already set by Set")
	}

	expectation := &StockServiceMockCancelStocksExpectation{
		mock:   mmCancelStocks.mock,
		params: &StockServiceMockCancelStocksParams{ctx, order},
	}
	mmCancelStocks.expectations = append(mmCancelStocks.expectations, expectation)
	return expectation
}

// Then sets up StockService.CancelStocks return parameters for the expectation previously defined by the When method
func (e *StockServiceMockCancelStocksExpectation) Then(err error) *StockServiceMock {
	e.results = &StockServiceMockCancelStocksResults{err}
	return e.mock
}

// Times sets number of times StockService.CancelStocks should be invoked
func (mmCancelStocks *mStockServiceMockCancelStocks) Times(n uint64) *mStockServiceMockCancelStocks {
	if n == 0 {
		mmCancelStocks.mock.t.Fatalf("Times of StockServiceMock.CancelStocks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCancelStocks.expectedInvocations, n)
	return mmCancelStocks
}

func (mmCancelStocks *mStockServiceMockCancelStocks) invocationsDone() bool {
	if len(mmCancelStocks.expectations) == 0 && mmCancelStocks.defaultExpectation == nil && mmCancelStocks.mock.funcCancelStocks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCancelStocks.mock.afterCancelStocksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCancelStocks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CancelStocks implements order.StockService
func (mmCancelStocks *StockServiceMock) CancelStocks(ctx context.Context, order model.Order) (err error) {
	mm_atomic.AddUint64(&mmCancelStocks.beforeCancelStocksCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelStocks.afterCancelStocksCounter, 1)

	if mmCancelStocks.inspectFuncCancelStocks != nil {
		mmCancelStocks.inspectFuncCancelStocks(ctx, order)
	}

	mm_params := StockServiceMockCancelStocksParams{ctx, order}

	// Record call args
	mmCancelStocks.CancelStocksMock.mutex.Lock()
	mmCancelStocks.CancelStocksMock.callArgs = append(mmCancelStocks.CancelStocksMock.callArgs, &mm_params)
	mmCancelStocks.CancelStocksMock.mutex.Unlock()

	for _, e := range mmCancelStocks.CancelStocksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCancelStocks.CancelStocksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelStocks.CancelStocksMock.defaultExpectation.Counter, 1)
		mm_want := mmCancelStocks.CancelStocksMock.defaultExpectation.params
		mm_want_ptrs := mmCancelStocks.CancelStocksMock.defaultExpectation.paramPtrs

		mm_got := StockServiceMockCancelStocksParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCancelStocks.t.Errorf("StockServiceMock.CancelStocks got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmCancelStocks.t.Errorf("StockServiceMock.CancelStocks got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCancelStocks.t.Errorf("StockServiceMock.CancelStocks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCancelStocks.CancelStocksMock.defaultExpectation.results
		if mm_results == nil {
			mmCancelStocks.t.Fatal("No results are set for the StockServiceMock.CancelStocks")
		}
		return (*mm_results).err
	}
	if mmCancelStocks.funcCancelStocks != nil {
		return mmCancelStocks.funcCancelStocks(ctx, order)
	}
	mmCancelStocks.t.Fatalf("Unexpected call to StockServiceMock.CancelStocks. %v %v", ctx, order)
	return
}

// CancelStocksAfterCounter returns a count of finished StockServiceMock.CancelStocks invocations
func (mmCancelStocks *StockServiceMock) CancelStocksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelStocks.afterCancelStocksCounter)
}

// CancelStocksBeforeCounter returns a count of StockServiceMock.CancelStocks invocations
func (mmCancelStocks *StockServiceMock) CancelStocksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelStocks.beforeCancelStocksCounter)
}

// Calls returns a list of arguments used in each call to StockServiceMock.CancelStocks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCancelStocks *mStockServiceMockCancelStocks) Calls() []*StockServiceMockCancelStocksParams {
	mmCancelStocks.mutex.RLock()

	argCopy := make([]*StockServiceMockCancelStocksParams, len(mmCancelStocks.callArgs))
	copy(argCopy, mmCancelStocks.callArgs)

	mmCancelStocks.mutex.RUnlock()

	return argCopy
}

// MinimockCancelStocksDone returns true if the count of the CancelStocks invocations corresponds
// the number of defined expectations
func (m *StockServiceMock) MinimockCancelStocksDone() bool {
	if m.CancelStocksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CancelStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CancelStocksMock.invocationsDone()
}

// MinimockCancelStocksInspect logs each unmet expectation
func (m *StockServiceMock) MinimockCancelStocksInspect() {
	for _, e := range m.CancelStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockServiceMock.CancelStocks with params: %#v", *e.params)
		}
	}

	afterCancelStocksCounter := mm_atomic.LoadUint64(&m.afterCancelStocksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CancelStocksMock.defaultExpectation != nil && afterCancelStocksCounter < 1 {
		if m.CancelStocksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockServiceMock.CancelStocks")
		} else {
			m.t.Errorf("Expected call to StockServiceMock.CancelStocks with params: %#v", *m.CancelStocksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelStocks != nil && afterCancelStocksCounter < 1 {
		m.t.Error("Expected call to StockServiceMock.CancelStocks")
	}

	if !m.CancelStocksMock.invocationsDone() && afterCancelStocksCounter > 0 {
		m.t.Errorf("Expected %d calls to StockServiceMock.CancelStocks but found %d calls",
			mm_atomic.LoadUint64(&m.CancelStocksMock.expectedInvocations), afterCancelStocksCounter)
	}
}

type mStockServiceMockPayStocks struct {
	optional           bool
	mock               *StockServiceMock
	defaultExpectation *StockServiceMockPayStocksExpectation
	expectations       []*StockServiceMockPayStocksExpectation

	callArgs []*StockServiceMockPayStocksParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockServiceMockPayStocksExpectation specifies expectation struct of the StockService.PayStocks
type StockServiceMockPayStocksExpectation struct {
	mock      *StockServiceMock
	params    *StockServiceMockPayStocksParams
	paramPtrs *StockServiceMockPayStocksParamPtrs
	results   *StockServiceMockPayStocksResults
	Counter   uint64
}

// StockServiceMockPayStocksParams contains parameters of the StockService.PayStocks
type StockServiceMockPayStocksParams struct {
	ctx   context.Context
	order model.Order
}

// StockServiceMockPayStocksParamPtrs contains pointers to parameters of the StockService.PayStocks
type StockServiceMockPayStocksParamPtrs struct {
	ctx   *context.Context
	order *model.Order
}

// StockServiceMockPayStocksResults contains results of the StockService.PayStocks
type StockServiceMockPayStocksResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPayStocks *mStockServiceMockPayStocks) Optional() *mStockServiceMockPayStocks {
	mmPayStocks.optional = true
	return mmPayStocks
}

// Expect sets up expected params for StockService.PayStocks
func (mmPayStocks *mStockServiceMockPayStocks) Expect(ctx context.Context, order model.Order) *mStockServiceMockPayStocks {
	if mmPayStocks.mock.funcPayStocks != nil {
		mmPayStocks.mock.t.Fatalf("StockServiceMock.PayStocks mock is already set by Set")
	}

	if mmPayStocks.defaultExpectation == nil {
		mmPayStocks.defaultExpectation = &StockServiceMockPayStocksExpectation{}
	}

	if mmPayStocks.defaultExpectation.paramPtrs != nil {
		mmPayStocks.mock.t.Fatalf("StockServiceMock.PayStocks mock is already set by ExpectParams functions")
	}

	mmPayStocks.defaultExpectation.params = &StockServiceMockPayStocksParams{ctx, order}
	for _, e := range mmPayStocks.expectations {
		if minimock.Equal(e.params, mmPayStocks.defaultExpectation.params) {
			mmPayStocks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPayStocks.defaultExpectation.params)
		}
	}

	return mmPayStocks
}

// ExpectCtxParam1 sets up expected param ctx for StockService.PayStocks
func (mmPayStocks *mStockServiceMockPayStocks) ExpectCtxParam1(ctx context.Context) *mStockServiceMockPayStocks {
	if mmPayStocks.mock.funcPayStocks != nil {
		mmPayStocks.mock.t.Fatalf("StockServiceMock.PayStocks mock is already set by Set")
	}

	if mmPayStocks.defaultExpectation == nil {
		mmPayStocks.defaultExpectation = &StockServiceMockPayStocksExpectation{}
	}

	if mmPayStocks.defaultExpectation.params != nil {
		mmPayStocks.mock.t.Fatalf("StockServiceMock.PayStocks mock is already set by Expect")
	}

	if mmPayStocks.defaultExpectation.paramPtrs == nil {
		mmPayStocks.defaultExpectation.paramPtrs = &StockServiceMockPayStocksParamPtrs{}
	}
	mmPayStocks.defaultExpectation.paramPtrs.ctx = &ctx

	return mmPayStocks
}

// ExpectOrderParam2 sets up expected param order for StockService.PayStocks
func (mmPayStocks *mStockServiceMockPayStocks) ExpectOrderParam2(order model.Order) *mStockServiceMockPayStocks {
	if mmPayStocks.mock.funcPayStocks != nil {
		mmPayStocks.mock.t.Fatalf("StockServiceMock.PayStocks mock is already set by Set")
	}

	if mmPayStocks.defaultExpectation == nil {
		mmPayStocks.defaultExpectation = &StockServiceMockPayStocksExpectation{}
	}

	if mmPayStocks.defaultExpectation.params != nil {
		mmPayStocks.mock.t.Fatalf("StockServiceMock.PayStocks mock is already set by Expect")
	}

	if mmPayStocks.defaultExpectation.paramPtrs == nil {
		mmPayStocks.defaultExpectation.paramPtrs = &StockServiceMockPayStocksParamPtrs{}
	}
	mmPayStocks.defaultExpectation.paramPtrs.order = &order

	return mmPayStocks
}

// Inspect accepts an inspector function that has same arguments as the StockService.PayStocks
func (mmPayStocks *mStockServiceMockPayStocks) Inspect(f func(ctx context.Context, order model.Order)) *mStockServiceMockPayStocks {
	if mmPayStocks.mock.inspectFuncPayStocks != nil {
		mmPayStocks.mock.t.Fatalf("Inspect function is already set for StockServiceMock.PayStocks")
	}

	mmPayStocks.mock.inspectFuncPayStocks = f

	return mmPayStocks
}

// Return sets up results that will be returned by StockService.PayStocks
func (mmPayStocks *mStockServiceMockPayStocks) Return(err error) *StockServiceMock {
	if mmPayStocks.mock.funcPayStocks != nil {
		mmPayStocks.mock.t.Fatalf("StockServiceMock.PayStocks mock is already set by Set")
	}

	if mmPayStocks.defaultExpectation == nil {
		mmPayStocks.defaultExpectation = &StockServiceMockPayStocksExpectation{mock: mmPayStocks.mock}
	}
	mmPayStocks.defaultExpectation.results = &StockServiceMockPayStocksResults{err}
	return mmPayStocks.mock
}

// Set uses given function f to mock the StockService.PayStocks method
func (mmPayStocks *mStockServiceMockPayStocks) Set(f func(ctx context.Context, order model.Order) (err error)) *StockServiceMock {
	if mmPayStocks.defaultExpectation != nil {
		mmPayStocks.mock.t.Fatalf("Default expectation is already set for the StockService.PayStocks method")
	}

	if len(mmPayStocks.expectations) > 0 {
		mmPayStocks.mock.t.Fatalf("Some expectations are already set for the StockService.PayStocks method")
	}

	mmPayStocks.mock.funcPayStocks = f
	return mmPayStocks.mock
}

// When sets expectation for the StockService.PayStocks which will trigger the result defined by the following
// Then helper
func (mmPayStocks *mStockServiceMockPayStocks) When(ctx context.Context, order model.Order) *StockServiceMockPayStocksExpectation {
	if mmPayStocks.mock.funcPayStocks != nil {
		mmPayStocks.mock.t.Fatalf("StockServiceMock.PayStocks mock is already set by Set")
	}

	expectation := &StockServiceMockPayStocksExpectation{
		mock:   mmPayStocks.mock,
		params: &StockServiceMockPayStocksParams{ctx, order},
	}
	mmPayStocks.expectations = append(mmPayStocks.expectations, expectation)
	return expectation
}

// Then sets up StockService.PayStocks return parameters for the expectation previously defined by the When method
func (e *StockServiceMockPayStocksExpectation) Then(err error) *StockServiceMock {
	e.results = &StockServiceMockPayStocksResults{err}
	return e.mock
}

// Times sets number of times StockService.PayStocks should be invoked
func (mmPayStocks *mStockServiceMockPayStocks) Times(n uint64) *mStockServiceMockPayStocks {
	if n == 0 {
		mmPayStocks.mock.t.Fatalf("Times of StockServiceMock.PayStocks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPayStocks.expectedInvocations, n)
	return mmPayStocks
}

func (mmPayStocks *mStockServiceMockPayStocks) invocationsDone() bool {
	if len(mmPayStocks.expectations) == 0 && mmPayStocks.defaultExpectation == nil && mmPayStocks.mock.funcPayStocks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPayStocks.mock.afterPayStocksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPayStocks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PayStocks implements order.StockService
func (mmPayStocks *StockServiceMock) PayStocks(ctx context.Context, order model.Order) (err error) {
	mm_atomic.AddUint64(&mmPayStocks.beforePayStocksCounter, 1)
	defer mm_atomic.AddUint64(&mmPayStocks.afterPayStocksCounter, 1)

	if mmPayStocks.inspectFuncPayStocks != nil {
		mmPayStocks.inspectFuncPayStocks(ctx, order)
	}

	mm_params := StockServiceMockPayStocksParams{ctx, order}

	// Record call args
	mmPayStocks.PayStocksMock.mutex.Lock()
	mmPayStocks.PayStocksMock.callArgs = append(mmPayStocks.PayStocksMock.callArgs, &mm_params)
	mmPayStocks.PayStocksMock.mutex.Unlock()

	for _, e := range mmPayStocks.PayStocksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPayStocks.PayStocksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPayStocks.PayStocksMock.defaultExpectation.Counter, 1)
		mm_want := mmPayStocks.PayStocksMock.defaultExpectation.params
		mm_want_ptrs := mmPayStocks.PayStocksMock.defaultExpectation.paramPtrs

		mm_got := StockServiceMockPayStocksParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPayStocks.t.Errorf("StockServiceMock.PayStocks got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmPayStocks.t.Errorf("StockServiceMock.PayStocks got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPayStocks.t.Errorf("StockServiceMock.PayStocks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPayStocks.PayStocksMock.defaultExpectation.results
		if mm_results == nil {
			mmPayStocks.t.Fatal("No results are set for the StockServiceMock.PayStocks")
		}
		return (*mm_results).err
	}
	if mmPayStocks.funcPayStocks != nil {
		return mmPayStocks.funcPayStocks(ctx, order)
	}
	mmPayStocks.t.Fatalf("Unexpected call to StockServiceMock.PayStocks. %v %v", ctx, order)
	return
}

// PayStocksAfterCounter returns a count of finished StockServiceMock.PayStocks invocations
func (mmPayStocks *StockServiceMock) PayStocksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPayStocks.afterPayStocksCounter)
}

// PayStocksBeforeCounter returns a count of StockServiceMock.PayStocks invocations
func (mmPayStocks *StockServiceMock) PayStocksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPayStocks.beforePayStocksCounter)
}

// Calls returns a list of arguments used in each call to StockServiceMock.PayStocks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPayStocks *mStockServiceMockPayStocks) Calls() []*StockServiceMockPayStocksParams {
	mmPayStocks.mutex.RLock()

	argCopy := make([]*StockServiceMockPayStocksParams, len(mmPayStocks.callArgs))
	copy(argCopy, mmPayStocks.callArgs)

	mmPayStocks.mutex.RUnlock()

	return argCopy
}

// MinimockPayStocksDone returns true if the count of the PayStocks invocations corresponds
// the number of defined expectations
func (m *StockServiceMock) MinimockPayStocksDone() bool {
	if m.PayStocksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PayStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PayStocksMock.invocationsDone()
}

// MinimockPayStocksInspect logs each unmet expectation
func (m *StockServiceMock) MinimockPayStocksInspect() {
	for _, e := range m.PayStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockServiceMock.PayStocks with params: %#v", *e.params)
		}
	}

	afterPayStocksCounter := mm_atomic.LoadUint64(&m.afterPayStocksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PayStocksMock.defaultExpectation != nil && afterPayStocksCounter < 1 {
		if m.PayStocksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockServiceMock.PayStocks")
		} else {
			m.t.Errorf("Expected call to StockServiceMock.PayStocks with params: %#v", *m.PayStocksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPayStocks != nil && afterPayStocksCounter < 1 {
		m.t.Error("Expected call to StockServiceMock.PayStocks")
	}

	if !m.PayStocksMock.invocationsDone() && afterPayStocksCounter > 0 {
		m.t.Errorf("Expected %d calls to StockServiceMock.PayStocks but found %d calls",
			mm_atomic.LoadUint64(&m.PayStocksMock.expectedInvocations), afterPayStocksCounter)
	}
}

type mStockServiceMockReserveStocks struct {
	optional           bool
	mock               *StockServiceMock
	defaultExpectation *StockServiceMockReserveStocksExpectation
	expectations       []*StockServiceMockReserveStocksExpectation

	callArgs []*StockServiceMockReserveStocksParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockServiceMockReserveStocksExpectation specifies expectation struct of the StockService.ReserveStocks
type StockServiceMockReserveStocksExpectation struct {
	mock      *StockServiceMock
	params    *StockServiceMockReserveStocksParams
	paramPtrs *StockServiceMockReserveStocksParamPtrs
	results   *StockServiceMockReserveStocksResults
	Counter   uint64
}

// StockServiceMockReserveStocksParams contains parameters of the StockService.ReserveStocks
type StockServiceMockReserveStocksParams struct {
	ctx   context.Context
	order model.Order
}

// StockServiceMockReserveStocksParamPtrs contains pointers to parameters of the StockService.ReserveStocks
type StockServiceMockReserveStocksParamPtrs struct {
	ctx   *context.Context
	order *model.Order
}

// StockServiceMockReserveStocksResults contains results of the StockService.ReserveStocks
type StockServiceMockReserveStocksResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveStocks *mStockServiceMockReserveStocks) Optional() *mStockServiceMockReserveStocks {
	mmReserveStocks.optional = true
	return mmReserveStocks
}

// Expect sets up expected params for StockService.ReserveStocks
func (mmReserveStocks *mStockServiceMockReserveStocks) Expect(ctx context.Context, order model.Order) *mStockServiceMockReserveStocks {
	if mmReserveStocks.mock.funcReserveStocks != nil {
		mmReserveStocks.mock.t.Fatalf("StockServiceMock.ReserveStocks mock is already set by Set")
	}

	if mmReserveStocks.defaultExpectation == nil {
		mmReserveStocks.defaultExpectation = &StockServiceMockReserveStocksExpectation{}
	}

	if mmReserveStocks.defaultExpectation.paramPtrs != nil {
		mmReserveStocks.mock.t.Fatalf("StockServiceMock.ReserveStocks mock is already set by ExpectParams functions")
	}

	mmReserveStocks.defaultExpectation.params = &StockServiceMockReserveStocksParams{ctx, order}
	for _, e := range mmReserveStocks.expectations {
		if minimock.Equal(e.params, mmReserveStocks.defaultExpectation.params) {
			mmReserveStocks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveStocks.defaultExpectation.params)
		}
	}

	return mmReserveStocks
}

// ExpectCtxParam1 sets up expected param ctx for StockService.ReserveStocks
func (mmReserveStocks *mStockServiceMockReserveStocks) ExpectCtxParam1(ctx context.Context) *mStockServiceMockReserveStocks {
	if mmReserveStocks.mock.funcReserveStocks != nil {
		mmReserveStocks.mock.t.Fatalf("StockServiceMock.ReserveStocks mock is already set by Set")
	}

	if mmReserveStocks.defaultExpectation == nil {
		mmReserveStocks.defaultExpectation = &StockServiceMockReserveStocksExpectation{}
	}

	if mmReserveStocks.defaultExpectation.params != nil {
		mmReserveStocks.mock.t.Fatalf("StockServiceMock.ReserveStocks mock is already set by Expect")
	}

	if mmReserveStocks.defaultExpectation.paramPtrs == nil {
		mmReserveStocks.defaultExpectation.paramPtrs = &StockServiceMockReserveStocksParamPtrs{}
	}
	mmReserveStocks.defaultExpectation.paramPtrs.ctx = &ctx

	return mmReserveStocks
}

// ExpectOrderParam2 sets up expected param order for StockService.ReserveStocks
func (mmReserveStocks *mStockServiceMockReserveStocks) ExpectOrderParam2(order model.Order) *mStockServiceMockReserveStocks {
	if mmReserveStocks.mock.funcReserveStocks != nil {
		mmReserveStocks.mock.t.Fatalf("StockServiceMock.ReserveStocks mock is already set by Set")
	}

	if mmReserveStocks.defaultExpectation == nil {
		mmReserveStocks.defaultExpectation = &StockServiceMockReserveStocksExpectation{}
	}

	if mmReserveStocks.defaultExpectation.params != nil {
		mmReserveStocks.mock.t.Fatalf("StockServiceMock.ReserveStocks mock is already set by Expect")
	}

	if mmReserveStocks.defaultExpectation.paramPtrs == nil {
		mmReserveStocks.defaultExpectation.paramPtrs = &StockServiceMockReserveStocksParamPtrs{}
	}
	mmReserveStocks.defaultExpectation.paramPtrs.order = &order

	return mmReserveStocks
}

// Inspect accepts an inspector function that has same arguments as the StockService.ReserveStocks
func (mmReserveStocks *mStockServiceMockReserveStocks) Inspect(f func(ctx context.Context, order model.Order)) *mStockServiceMockReserveStocks {
	if mmReserveStocks.mock.inspectFuncReserveStocks != nil {
		mmReserveStocks.mock.t.Fatalf("Inspect function is already set for StockServiceMock.ReserveStocks")
	}

	mmReserveStocks.mock.inspectFuncReserveStocks = f

	return mmReserveStocks
}

// Return sets up results that will be returned by StockService.ReserveStocks
func (mmReserveStocks *mStockServiceMockReserveStocks) Return(err error) *StockServiceMock {
	if mmReserveStocks.mock.funcReserveStocks != nil {
		mmReserveStocks.mock.t.Fatalf("StockServiceMock.ReserveStocks mock is already set by Set")
	}

	if mmReserveStocks.defaultExpectation == nil {
		mmReserveStocks.defaultExpectation = &StockServiceMockReserveStocksExpectation{mock: mmReserveStocks.mock}
	}
	mmReserveStocks.defaultExpectation.results = &StockServiceMockReserveStocksResults{err}
	return mmReserveStocks.mock
}

// Set uses given function f to mock the StockService.ReserveStocks method
func (mmReserveStocks *mStockServiceMockReserveStocks) Set(f func(ctx context.Context, order model.Order) (err error)) *StockServiceMock {
	if mmReserveStocks.defaultExpectation != nil {
		mmReserveStocks.mock.t.Fatalf("Default expectation is already set for the StockService.ReserveStocks method")
	}

	if len(mmReserveStocks.expectations) > 0 {
		mmReserveStocks.mock.t.Fatalf("Some expectations are already set for the StockService.ReserveStocks method")
	}

	mmReserveStocks.mock.funcReserveStocks = f
	return mmReserveStocks.mock
}

// When sets expectation for the StockService.ReserveStocks which will trigger the result defined by the following
// Then helper
func (mmReserveStocks *mStockServiceMockReserveStocks) When(ctx context.Context, order model.Order) *StockServiceMockReserveStocksExpectation {
	if mmReserveStocks.mock.funcReserveStocks != nil {
		mmReserveStocks.mock.t.Fatalf("StockServiceMock.ReserveStocks mock is already set by Set")
	}

	expectation := &StockServiceMockReserveStocksExpectation{
		mock:   mmReserveStocks.mock,
		params: &StockServiceMockReserveStocksParams{ctx, order},
	}
	mmReserveStocks.expectations = append(mmReserveStocks.expectations, expectation)
	return expectation
}

// Then sets up StockService.ReserveStocks return parameters for the expectation previously defined by the When method
func (e *StockServiceMockReserveStocksExpectation) Then(err error) *StockServiceMock {
	e.results = &StockServiceMockReserveStocksResults{err}
	return e.mock
}

// Times sets number of times StockService.ReserveStocks should be invoked
func (mmReserveStocks *mStockServiceMockReserveStocks) Times(n uint64) *mStockServiceMockReserveStocks {
	if n == 0 {
		mmReserveStocks.mock.t.Fatalf("Times of StockServiceMock.ReserveStocks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveStocks.expectedInvocations, n)
	return mmReserveStocks
}

func (mmReserveStocks *mStockServiceMockReserveStocks) invocationsDone() bool {
	if len(mmReserveStocks.expectations) == 0 && mmReserveStocks.defaultExpectation == nil && mmReserveStocks.mock.funcReserveStocks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveStocks.mock.afterReserveStocksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveStocks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveStocks implements order.StockService
func (mmReserveStocks *StockServiceMock) ReserveStocks(ctx context.Context, order model.Order) (err error) {
	mm_atomic.AddUint64(&mmReserveStocks.beforeReserveStocksCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveStocks.afterReserveStocksCounter, 1)

	if mmReserveStocks.inspectFuncReserveStocks != nil {
		mmReserveStocks.inspectFuncReserveStocks(ctx, order)
	}

	mm_params := StockServiceMockReserveStocksParams{ctx, order}

	// Record call args
	mmReserveStocks.ReserveStocksMock.mutex.Lock()
	mmReserveStocks.ReserveStocksMock.callArgs = append(mmReserveStocks.ReserveStocksMock.callArgs, &mm_params)
	mmReserveStocks.ReserveStocksMock.mutex.Unlock()

	for _, e := range mmReserveStocks.ReserveStocksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveStocks.ReserveStocksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveStocks.ReserveStocksMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveStocks.ReserveStocksMock.defaultExpectation.params
		mm_want_ptrs := mmReserveStocks.ReserveStocksMock.defaultExpectation.paramPtrs

		mm_got := StockServiceMockReserveStocksParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveStocks.t.Errorf("StockServiceMock.ReserveStocks got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmReserveStocks.t.Errorf("StockServiceMock.ReserveStocks got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveStocks.t.Errorf("StockServiceMock.ReserveStocks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveStocks.ReserveStocksMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveStocks.t.Fatal("No results are set for the StockServiceMock.ReserveStocks")
		}
		return (*mm_results).err
	}
	if mmReserveStocks.funcReserveStocks != nil {
		return mmReserveStocks.funcReserveStocks(ctx, order)
	}
	mmReserveStocks.t.Fatalf("Unexpected call to StockServiceMock.ReserveStocks. %v %v", ctx, order)
	return
}

// ReserveStocksAfterCounter returns a count of finished StockServiceMock.ReserveStocks invocations
func (mmReserveStocks *StockServiceMock) ReserveStocksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveStocks.afterReserveStocksCounter)
}

// ReserveStocksBeforeCounter returns a count of StockServiceMock.ReserveStocks invocations
func (mmReserveStocks *StockServiceMock) ReserveStocksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveStocks.beforeReserveStocksCounter)
}

// Calls returns a list of arguments used in each call to StockServiceMock.ReserveStocks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveStocks *mStockServiceMockReserveStocks) Calls() []*StockServiceMockReserveStocksParams {
	mmReserveStocks.mutex.RLock()

	argCopy := make([]*StockServiceMockReserveStocksParams, len(mmReserveStocks.callArgs))
	copy(argCopy, mmReserveStocks.callArgs)

	mmReserveStocks.mutex.RUnlock()

	return argCopy
}

// MinimockReserveStocksDone returns true if the count of the ReserveStocks invocations corresponds
// the number of defined expectations
func (m *StockServiceMock) MinimockReserveStocksDone() bool {
	if m.ReserveStocksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveStocksMock.invocationsDone()
}

// MinimockReserveStocksInspect logs each unmet expectation
func (m *StockServiceMock) MinimockReserveStocksInspect() {
	for _, e := range m.ReserveStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockServiceMock.ReserveStocks with params: %#v", *e.params)
		}
	}

	afterReserveStocksCounter := mm_atomic.LoadUint64(&m.afterReserveStocksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveStocksMock.defaultExpectation != nil && afterReserveStocksCounter < 1 {
		if m.ReserveStocksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockServiceMock.ReserveStocks")
		} else {
			m.t.Errorf("Expected call to StockServiceMock.ReserveStocks with params: %#v", *m.ReserveStocksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveStocks != nil && afterReserveStocksCounter < 1 {
		m.t.Error("Expected call to StockServiceMock.ReserveStocks")
	}

	if !m.ReserveStocksMock.invocationsDone() && afterReserveStocksCounter > 0 {
		m.t.Errorf("Expected %d calls to StockServiceMock.ReserveStocks but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveStocksMock.expectedInvocations), afterReserveStocksCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StockServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCancelStocksInspect()

			m.MinimockPayStocksInspect()

			m.MinimockReserveStocksInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StockServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StockServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelStocksDone() &&
		m.MinimockPayStocksDone() &&
		m.MinimockReserveStocksDone()
}
