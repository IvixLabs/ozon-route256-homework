// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package mock

//go:generate minimock -i route256/cart/internal/usecase/cart.Repository -o repository_mock.go -n RepositoryMock -p mock

import (
	"context"
	"route256/cart/internal/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements cart.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetCart          func(ctx context.Context, userId model.UserID) (cp1 *model.Cart, err error)
	inspectFuncGetCart   func(ctx context.Context, userId model.UserID)
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mRepositoryMockGetCart

	funcHasCart          func(ctx context.Context, userId model.UserID) (b1 bool)
	inspectFuncHasCart   func(ctx context.Context, userId model.UserID)
	afterHasCartCounter  uint64
	beforeHasCartCounter uint64
	HasCartMock          mRepositoryMockHasCart

	funcRemoveCart          func(ctx context.Context, userId model.UserID)
	inspectFuncRemoveCart   func(ctx context.Context, userId model.UserID)
	afterRemoveCartCounter  uint64
	beforeRemoveCartCounter uint64
	RemoveCartMock          mRepositoryMockRemoveCart

	funcUpdateCart          func(ctx context.Context, cart *model.Cart)
	inspectFuncUpdateCart   func(ctx context.Context, cart *model.Cart)
	afterUpdateCartCounter  uint64
	beforeUpdateCartCounter uint64
	UpdateCartMock          mRepositoryMockUpdateCart
}

// NewRepositoryMock returns a mock for cart.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetCartMock = mRepositoryMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*RepositoryMockGetCartParams{}

	m.HasCartMock = mRepositoryMockHasCart{mock: m}
	m.HasCartMock.callArgs = []*RepositoryMockHasCartParams{}

	m.RemoveCartMock = mRepositoryMockRemoveCart{mock: m}
	m.RemoveCartMock.callArgs = []*RepositoryMockRemoveCartParams{}

	m.UpdateCartMock = mRepositoryMockUpdateCart{mock: m}
	m.UpdateCartMock.callArgs = []*RepositoryMockUpdateCartParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockGetCart struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetCartExpectation
	expectations       []*RepositoryMockGetCartExpectation

	callArgs []*RepositoryMockGetCartParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetCartExpectation specifies expectation struct of the Repository.GetCart
type RepositoryMockGetCartExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetCartParams
	paramPtrs *RepositoryMockGetCartParamPtrs
	results   *RepositoryMockGetCartResults
	Counter   uint64
}

// RepositoryMockGetCartParams contains parameters of the Repository.GetCart
type RepositoryMockGetCartParams struct {
	ctx    context.Context
	userId model.UserID
}

// RepositoryMockGetCartParamPtrs contains pointers to parameters of the Repository.GetCart
type RepositoryMockGetCartParamPtrs struct {
	ctx    *context.Context
	userId *model.UserID
}

// RepositoryMockGetCartResults contains results of the Repository.GetCart
type RepositoryMockGetCartResults struct {
	cp1 *model.Cart
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCart *mRepositoryMockGetCart) Optional() *mRepositoryMockGetCart {
	mmGetCart.optional = true
	return mmGetCart
}

// Expect sets up expected params for Repository.GetCart
func (mmGetCart *mRepositoryMockGetCart) Expect(ctx context.Context, userId model.UserID) *mRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("RepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &RepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.paramPtrs != nil {
		mmGetCart.mock.t.Fatalf("RepositoryMock.GetCart mock is already set by ExpectParams functions")
	}

	mmGetCart.defaultExpectation.params = &RepositoryMockGetCartParams{ctx, userId}
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetCart
func (mmGetCart *mRepositoryMockGetCart) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("RepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &RepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("RepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &RepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetCart
}

// ExpectUserIdParam2 sets up expected param userId for Repository.GetCart
func (mmGetCart *mRepositoryMockGetCart) ExpectUserIdParam2(userId model.UserID) *mRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("RepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &RepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("RepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &RepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.userId = &userId

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetCart
func (mmGetCart *mRepositoryMockGetCart) Inspect(f func(ctx context.Context, userId model.UserID)) *mRepositoryMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by Repository.GetCart
func (mmGetCart *mRepositoryMockGetCart) Return(cp1 *model.Cart, err error) *RepositoryMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("RepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &RepositoryMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &RepositoryMockGetCartResults{cp1, err}
	return mmGetCart.mock
}

// Set uses given function f to mock the Repository.GetCart method
func (mmGetCart *mRepositoryMockGetCart) Set(f func(ctx context.Context, userId model.UserID) (cp1 *model.Cart, err error)) *RepositoryMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the Repository.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the Repository.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	return mmGetCart.mock
}

// When sets expectation for the Repository.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mRepositoryMockGetCart) When(ctx context.Context, userId model.UserID) *RepositoryMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("RepositoryMock.GetCart mock is already set by Set")
	}

	expectation := &RepositoryMockGetCartExpectation{
		mock:   mmGetCart.mock,
		params: &RepositoryMockGetCartParams{ctx, userId},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetCartExpectation) Then(cp1 *model.Cart, err error) *RepositoryMock {
	e.results = &RepositoryMockGetCartResults{cp1, err}
	return e.mock
}

// Times sets number of times Repository.GetCart should be invoked
func (mmGetCart *mRepositoryMockGetCart) Times(n uint64) *mRepositoryMockGetCart {
	if n == 0 {
		mmGetCart.mock.t.Fatalf("Times of RepositoryMock.GetCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCart.expectedInvocations, n)
	return mmGetCart
}

func (mmGetCart *mRepositoryMockGetCart) invocationsDone() bool {
	if len(mmGetCart.expectations) == 0 && mmGetCart.defaultExpectation == nil && mmGetCart.mock.funcGetCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCart.mock.afterGetCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCart implements cart.Repository
func (mmGetCart *RepositoryMock) GetCart(ctx context.Context, userId model.UserID) (cp1 *model.Cart, err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(ctx, userId)
	}

	mm_params := RepositoryMockGetCartParams{ctx, userId}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, &mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_want_ptrs := mmGetCart.GetCartMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetCartParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCart.t.Errorf("RepositoryMock.GetCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmGetCart.t.Errorf("RepositoryMock.GetCart got unexpected parameter userId, want: %#v, got: %#v%s\n", *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("RepositoryMock.GetCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the RepositoryMock.GetCart")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(ctx, userId)
	}
	mmGetCart.t.Fatalf("Unexpected call to RepositoryMock.GetCart. %v %v", ctx, userId)
	return
}

// GetCartAfterCounter returns a count of finished RepositoryMock.GetCart invocations
func (mmGetCart *RepositoryMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of RepositoryMock.GetCart invocations
func (mmGetCart *RepositoryMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mRepositoryMockGetCart) Calls() []*RepositoryMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*RepositoryMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetCartDone() bool {
	if m.GetCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartMock.invocationsDone()
}

// MinimockGetCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetCart with params: %#v", *e.params)
		}
	}

	afterGetCartCounter := mm_atomic.LoadUint64(&m.afterGetCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && afterGetCartCounter < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetCart")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetCart with params: %#v", *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && afterGetCartCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetCart")
	}

	if !m.GetCartMock.invocationsDone() && afterGetCartCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetCart but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartMock.expectedInvocations), afterGetCartCounter)
	}
}

type mRepositoryMockHasCart struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockHasCartExpectation
	expectations       []*RepositoryMockHasCartExpectation

	callArgs []*RepositoryMockHasCartParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockHasCartExpectation specifies expectation struct of the Repository.HasCart
type RepositoryMockHasCartExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockHasCartParams
	paramPtrs *RepositoryMockHasCartParamPtrs
	results   *RepositoryMockHasCartResults
	Counter   uint64
}

// RepositoryMockHasCartParams contains parameters of the Repository.HasCart
type RepositoryMockHasCartParams struct {
	ctx    context.Context
	userId model.UserID
}

// RepositoryMockHasCartParamPtrs contains pointers to parameters of the Repository.HasCart
type RepositoryMockHasCartParamPtrs struct {
	ctx    *context.Context
	userId *model.UserID
}

// RepositoryMockHasCartResults contains results of the Repository.HasCart
type RepositoryMockHasCartResults struct {
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHasCart *mRepositoryMockHasCart) Optional() *mRepositoryMockHasCart {
	mmHasCart.optional = true
	return mmHasCart
}

// Expect sets up expected params for Repository.HasCart
func (mmHasCart *mRepositoryMockHasCart) Expect(ctx context.Context, userId model.UserID) *mRepositoryMockHasCart {
	if mmHasCart.mock.funcHasCart != nil {
		mmHasCart.mock.t.Fatalf("RepositoryMock.HasCart mock is already set by Set")
	}

	if mmHasCart.defaultExpectation == nil {
		mmHasCart.defaultExpectation = &RepositoryMockHasCartExpectation{}
	}

	if mmHasCart.defaultExpectation.paramPtrs != nil {
		mmHasCart.mock.t.Fatalf("RepositoryMock.HasCart mock is already set by ExpectParams functions")
	}

	mmHasCart.defaultExpectation.params = &RepositoryMockHasCartParams{ctx, userId}
	for _, e := range mmHasCart.expectations {
		if minimock.Equal(e.params, mmHasCart.defaultExpectation.params) {
			mmHasCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHasCart.defaultExpectation.params)
		}
	}

	return mmHasCart
}

// ExpectCtxParam1 sets up expected param ctx for Repository.HasCart
func (mmHasCart *mRepositoryMockHasCart) ExpectCtxParam1(ctx context.Context) *mRepositoryMockHasCart {
	if mmHasCart.mock.funcHasCart != nil {
		mmHasCart.mock.t.Fatalf("RepositoryMock.HasCart mock is already set by Set")
	}

	if mmHasCart.defaultExpectation == nil {
		mmHasCart.defaultExpectation = &RepositoryMockHasCartExpectation{}
	}

	if mmHasCart.defaultExpectation.params != nil {
		mmHasCart.mock.t.Fatalf("RepositoryMock.HasCart mock is already set by Expect")
	}

	if mmHasCart.defaultExpectation.paramPtrs == nil {
		mmHasCart.defaultExpectation.paramPtrs = &RepositoryMockHasCartParamPtrs{}
	}
	mmHasCart.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHasCart
}

// ExpectUserIdParam2 sets up expected param userId for Repository.HasCart
func (mmHasCart *mRepositoryMockHasCart) ExpectUserIdParam2(userId model.UserID) *mRepositoryMockHasCart {
	if mmHasCart.mock.funcHasCart != nil {
		mmHasCart.mock.t.Fatalf("RepositoryMock.HasCart mock is already set by Set")
	}

	if mmHasCart.defaultExpectation == nil {
		mmHasCart.defaultExpectation = &RepositoryMockHasCartExpectation{}
	}

	if mmHasCart.defaultExpectation.params != nil {
		mmHasCart.mock.t.Fatalf("RepositoryMock.HasCart mock is already set by Expect")
	}

	if mmHasCart.defaultExpectation.paramPtrs == nil {
		mmHasCart.defaultExpectation.paramPtrs = &RepositoryMockHasCartParamPtrs{}
	}
	mmHasCart.defaultExpectation.paramPtrs.userId = &userId

	return mmHasCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.HasCart
func (mmHasCart *mRepositoryMockHasCart) Inspect(f func(ctx context.Context, userId model.UserID)) *mRepositoryMockHasCart {
	if mmHasCart.mock.inspectFuncHasCart != nil {
		mmHasCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.HasCart")
	}

	mmHasCart.mock.inspectFuncHasCart = f

	return mmHasCart
}

// Return sets up results that will be returned by Repository.HasCart
func (mmHasCart *mRepositoryMockHasCart) Return(b1 bool) *RepositoryMock {
	if mmHasCart.mock.funcHasCart != nil {
		mmHasCart.mock.t.Fatalf("RepositoryMock.HasCart mock is already set by Set")
	}

	if mmHasCart.defaultExpectation == nil {
		mmHasCart.defaultExpectation = &RepositoryMockHasCartExpectation{mock: mmHasCart.mock}
	}
	mmHasCart.defaultExpectation.results = &RepositoryMockHasCartResults{b1}
	return mmHasCart.mock
}

// Set uses given function f to mock the Repository.HasCart method
func (mmHasCart *mRepositoryMockHasCart) Set(f func(ctx context.Context, userId model.UserID) (b1 bool)) *RepositoryMock {
	if mmHasCart.defaultExpectation != nil {
		mmHasCart.mock.t.Fatalf("Default expectation is already set for the Repository.HasCart method")
	}

	if len(mmHasCart.expectations) > 0 {
		mmHasCart.mock.t.Fatalf("Some expectations are already set for the Repository.HasCart method")
	}

	mmHasCart.mock.funcHasCart = f
	return mmHasCart.mock
}

// When sets expectation for the Repository.HasCart which will trigger the result defined by the following
// Then helper
func (mmHasCart *mRepositoryMockHasCart) When(ctx context.Context, userId model.UserID) *RepositoryMockHasCartExpectation {
	if mmHasCart.mock.funcHasCart != nil {
		mmHasCart.mock.t.Fatalf("RepositoryMock.HasCart mock is already set by Set")
	}

	expectation := &RepositoryMockHasCartExpectation{
		mock:   mmHasCart.mock,
		params: &RepositoryMockHasCartParams{ctx, userId},
	}
	mmHasCart.expectations = append(mmHasCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.HasCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockHasCartExpectation) Then(b1 bool) *RepositoryMock {
	e.results = &RepositoryMockHasCartResults{b1}
	return e.mock
}

// Times sets number of times Repository.HasCart should be invoked
func (mmHasCart *mRepositoryMockHasCart) Times(n uint64) *mRepositoryMockHasCart {
	if n == 0 {
		mmHasCart.mock.t.Fatalf("Times of RepositoryMock.HasCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHasCart.expectedInvocations, n)
	return mmHasCart
}

func (mmHasCart *mRepositoryMockHasCart) invocationsDone() bool {
	if len(mmHasCart.expectations) == 0 && mmHasCart.defaultExpectation == nil && mmHasCart.mock.funcHasCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHasCart.mock.afterHasCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHasCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HasCart implements cart.Repository
func (mmHasCart *RepositoryMock) HasCart(ctx context.Context, userId model.UserID) (b1 bool) {
	mm_atomic.AddUint64(&mmHasCart.beforeHasCartCounter, 1)
	defer mm_atomic.AddUint64(&mmHasCart.afterHasCartCounter, 1)

	if mmHasCart.inspectFuncHasCart != nil {
		mmHasCart.inspectFuncHasCart(ctx, userId)
	}

	mm_params := RepositoryMockHasCartParams{ctx, userId}

	// Record call args
	mmHasCart.HasCartMock.mutex.Lock()
	mmHasCart.HasCartMock.callArgs = append(mmHasCart.HasCartMock.callArgs, &mm_params)
	mmHasCart.HasCartMock.mutex.Unlock()

	for _, e := range mmHasCart.HasCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmHasCart.HasCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHasCart.HasCartMock.defaultExpectation.Counter, 1)
		mm_want := mmHasCart.HasCartMock.defaultExpectation.params
		mm_want_ptrs := mmHasCart.HasCartMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockHasCartParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHasCart.t.Errorf("RepositoryMock.HasCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmHasCart.t.Errorf("RepositoryMock.HasCart got unexpected parameter userId, want: %#v, got: %#v%s\n", *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHasCart.t.Errorf("RepositoryMock.HasCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHasCart.HasCartMock.defaultExpectation.results
		if mm_results == nil {
			mmHasCart.t.Fatal("No results are set for the RepositoryMock.HasCart")
		}
		return (*mm_results).b1
	}
	if mmHasCart.funcHasCart != nil {
		return mmHasCart.funcHasCart(ctx, userId)
	}
	mmHasCart.t.Fatalf("Unexpected call to RepositoryMock.HasCart. %v %v", ctx, userId)
	return
}

// HasCartAfterCounter returns a count of finished RepositoryMock.HasCart invocations
func (mmHasCart *RepositoryMock) HasCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasCart.afterHasCartCounter)
}

// HasCartBeforeCounter returns a count of RepositoryMock.HasCart invocations
func (mmHasCart *RepositoryMock) HasCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasCart.beforeHasCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.HasCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHasCart *mRepositoryMockHasCart) Calls() []*RepositoryMockHasCartParams {
	mmHasCart.mutex.RLock()

	argCopy := make([]*RepositoryMockHasCartParams, len(mmHasCart.callArgs))
	copy(argCopy, mmHasCart.callArgs)

	mmHasCart.mutex.RUnlock()

	return argCopy
}

// MinimockHasCartDone returns true if the count of the HasCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockHasCartDone() bool {
	if m.HasCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HasCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HasCartMock.invocationsDone()
}

// MinimockHasCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockHasCartInspect() {
	for _, e := range m.HasCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.HasCart with params: %#v", *e.params)
		}
	}

	afterHasCartCounter := mm_atomic.LoadUint64(&m.afterHasCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HasCartMock.defaultExpectation != nil && afterHasCartCounter < 1 {
		if m.HasCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.HasCart")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.HasCart with params: %#v", *m.HasCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasCart != nil && afterHasCartCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.HasCart")
	}

	if !m.HasCartMock.invocationsDone() && afterHasCartCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.HasCart but found %d calls",
			mm_atomic.LoadUint64(&m.HasCartMock.expectedInvocations), afterHasCartCounter)
	}
}

type mRepositoryMockRemoveCart struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockRemoveCartExpectation
	expectations       []*RepositoryMockRemoveCartExpectation

	callArgs []*RepositoryMockRemoveCartParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockRemoveCartExpectation specifies expectation struct of the Repository.RemoveCart
type RepositoryMockRemoveCartExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockRemoveCartParams
	paramPtrs *RepositoryMockRemoveCartParamPtrs

	Counter uint64
}

// RepositoryMockRemoveCartParams contains parameters of the Repository.RemoveCart
type RepositoryMockRemoveCartParams struct {
	ctx    context.Context
	userId model.UserID
}

// RepositoryMockRemoveCartParamPtrs contains pointers to parameters of the Repository.RemoveCart
type RepositoryMockRemoveCartParamPtrs struct {
	ctx    *context.Context
	userId *model.UserID
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveCart *mRepositoryMockRemoveCart) Optional() *mRepositoryMockRemoveCart {
	mmRemoveCart.optional = true
	return mmRemoveCart
}

// Expect sets up expected params for Repository.RemoveCart
func (mmRemoveCart *mRepositoryMockRemoveCart) Expect(ctx context.Context, userId model.UserID) *mRepositoryMockRemoveCart {
	if mmRemoveCart.mock.funcRemoveCart != nil {
		mmRemoveCart.mock.t.Fatalf("RepositoryMock.RemoveCart mock is already set by Set")
	}

	if mmRemoveCart.defaultExpectation == nil {
		mmRemoveCart.defaultExpectation = &RepositoryMockRemoveCartExpectation{}
	}

	if mmRemoveCart.defaultExpectation.paramPtrs != nil {
		mmRemoveCart.mock.t.Fatalf("RepositoryMock.RemoveCart mock is already set by ExpectParams functions")
	}

	mmRemoveCart.defaultExpectation.params = &RepositoryMockRemoveCartParams{ctx, userId}
	for _, e := range mmRemoveCart.expectations {
		if minimock.Equal(e.params, mmRemoveCart.defaultExpectation.params) {
			mmRemoveCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveCart.defaultExpectation.params)
		}
	}

	return mmRemoveCart
}

// ExpectCtxParam1 sets up expected param ctx for Repository.RemoveCart
func (mmRemoveCart *mRepositoryMockRemoveCart) ExpectCtxParam1(ctx context.Context) *mRepositoryMockRemoveCart {
	if mmRemoveCart.mock.funcRemoveCart != nil {
		mmRemoveCart.mock.t.Fatalf("RepositoryMock.RemoveCart mock is already set by Set")
	}

	if mmRemoveCart.defaultExpectation == nil {
		mmRemoveCart.defaultExpectation = &RepositoryMockRemoveCartExpectation{}
	}

	if mmRemoveCart.defaultExpectation.params != nil {
		mmRemoveCart.mock.t.Fatalf("RepositoryMock.RemoveCart mock is already set by Expect")
	}

	if mmRemoveCart.defaultExpectation.paramPtrs == nil {
		mmRemoveCart.defaultExpectation.paramPtrs = &RepositoryMockRemoveCartParamPtrs{}
	}
	mmRemoveCart.defaultExpectation.paramPtrs.ctx = &ctx

	return mmRemoveCart
}

// ExpectUserIdParam2 sets up expected param userId for Repository.RemoveCart
func (mmRemoveCart *mRepositoryMockRemoveCart) ExpectUserIdParam2(userId model.UserID) *mRepositoryMockRemoveCart {
	if mmRemoveCart.mock.funcRemoveCart != nil {
		mmRemoveCart.mock.t.Fatalf("RepositoryMock.RemoveCart mock is already set by Set")
	}

	if mmRemoveCart.defaultExpectation == nil {
		mmRemoveCart.defaultExpectation = &RepositoryMockRemoveCartExpectation{}
	}

	if mmRemoveCart.defaultExpectation.params != nil {
		mmRemoveCart.mock.t.Fatalf("RepositoryMock.RemoveCart mock is already set by Expect")
	}

	if mmRemoveCart.defaultExpectation.paramPtrs == nil {
		mmRemoveCart.defaultExpectation.paramPtrs = &RepositoryMockRemoveCartParamPtrs{}
	}
	mmRemoveCart.defaultExpectation.paramPtrs.userId = &userId

	return mmRemoveCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.RemoveCart
func (mmRemoveCart *mRepositoryMockRemoveCart) Inspect(f func(ctx context.Context, userId model.UserID)) *mRepositoryMockRemoveCart {
	if mmRemoveCart.mock.inspectFuncRemoveCart != nil {
		mmRemoveCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.RemoveCart")
	}

	mmRemoveCart.mock.inspectFuncRemoveCart = f

	return mmRemoveCart
}

// Return sets up results that will be returned by Repository.RemoveCart
func (mmRemoveCart *mRepositoryMockRemoveCart) Return() *RepositoryMock {
	if mmRemoveCart.mock.funcRemoveCart != nil {
		mmRemoveCart.mock.t.Fatalf("RepositoryMock.RemoveCart mock is already set by Set")
	}

	if mmRemoveCart.defaultExpectation == nil {
		mmRemoveCart.defaultExpectation = &RepositoryMockRemoveCartExpectation{mock: mmRemoveCart.mock}
	}

	return mmRemoveCart.mock
}

// Set uses given function f to mock the Repository.RemoveCart method
func (mmRemoveCart *mRepositoryMockRemoveCart) Set(f func(ctx context.Context, userId model.UserID)) *RepositoryMock {
	if mmRemoveCart.defaultExpectation != nil {
		mmRemoveCart.mock.t.Fatalf("Default expectation is already set for the Repository.RemoveCart method")
	}

	if len(mmRemoveCart.expectations) > 0 {
		mmRemoveCart.mock.t.Fatalf("Some expectations are already set for the Repository.RemoveCart method")
	}

	mmRemoveCart.mock.funcRemoveCart = f
	return mmRemoveCart.mock
}

// Times sets number of times Repository.RemoveCart should be invoked
func (mmRemoveCart *mRepositoryMockRemoveCart) Times(n uint64) *mRepositoryMockRemoveCart {
	if n == 0 {
		mmRemoveCart.mock.t.Fatalf("Times of RepositoryMock.RemoveCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveCart.expectedInvocations, n)
	return mmRemoveCart
}

func (mmRemoveCart *mRepositoryMockRemoveCart) invocationsDone() bool {
	if len(mmRemoveCart.expectations) == 0 && mmRemoveCart.defaultExpectation == nil && mmRemoveCart.mock.funcRemoveCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveCart.mock.afterRemoveCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveCart implements cart.Repository
func (mmRemoveCart *RepositoryMock) RemoveCart(ctx context.Context, userId model.UserID) {
	mm_atomic.AddUint64(&mmRemoveCart.beforeRemoveCartCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveCart.afterRemoveCartCounter, 1)

	if mmRemoveCart.inspectFuncRemoveCart != nil {
		mmRemoveCart.inspectFuncRemoveCart(ctx, userId)
	}

	mm_params := RepositoryMockRemoveCartParams{ctx, userId}

	// Record call args
	mmRemoveCart.RemoveCartMock.mutex.Lock()
	mmRemoveCart.RemoveCartMock.callArgs = append(mmRemoveCart.RemoveCartMock.callArgs, &mm_params)
	mmRemoveCart.RemoveCartMock.mutex.Unlock()

	for _, e := range mmRemoveCart.RemoveCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRemoveCart.RemoveCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveCart.RemoveCartMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveCart.RemoveCartMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveCart.RemoveCartMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockRemoveCartParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveCart.t.Errorf("RepositoryMock.RemoveCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmRemoveCart.t.Errorf("RepositoryMock.RemoveCart got unexpected parameter userId, want: %#v, got: %#v%s\n", *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveCart.t.Errorf("RepositoryMock.RemoveCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmRemoveCart.funcRemoveCart != nil {
		mmRemoveCart.funcRemoveCart(ctx, userId)
		return
	}
	mmRemoveCart.t.Fatalf("Unexpected call to RepositoryMock.RemoveCart. %v %v", ctx, userId)

}

// RemoveCartAfterCounter returns a count of finished RepositoryMock.RemoveCart invocations
func (mmRemoveCart *RepositoryMock) RemoveCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveCart.afterRemoveCartCounter)
}

// RemoveCartBeforeCounter returns a count of RepositoryMock.RemoveCart invocations
func (mmRemoveCart *RepositoryMock) RemoveCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveCart.beforeRemoveCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.RemoveCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveCart *mRepositoryMockRemoveCart) Calls() []*RepositoryMockRemoveCartParams {
	mmRemoveCart.mutex.RLock()

	argCopy := make([]*RepositoryMockRemoveCartParams, len(mmRemoveCart.callArgs))
	copy(argCopy, mmRemoveCart.callArgs)

	mmRemoveCart.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveCartDone returns true if the count of the RemoveCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockRemoveCartDone() bool {
	if m.RemoveCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveCartMock.invocationsDone()
}

// MinimockRemoveCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockRemoveCartInspect() {
	for _, e := range m.RemoveCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.RemoveCart with params: %#v", *e.params)
		}
	}

	afterRemoveCartCounter := mm_atomic.LoadUint64(&m.afterRemoveCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveCartMock.defaultExpectation != nil && afterRemoveCartCounter < 1 {
		if m.RemoveCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.RemoveCart")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.RemoveCart with params: %#v", *m.RemoveCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveCart != nil && afterRemoveCartCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.RemoveCart")
	}

	if !m.RemoveCartMock.invocationsDone() && afterRemoveCartCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.RemoveCart but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveCartMock.expectedInvocations), afterRemoveCartCounter)
	}
}

type mRepositoryMockUpdateCart struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateCartExpectation
	expectations       []*RepositoryMockUpdateCartExpectation

	callArgs []*RepositoryMockUpdateCartParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockUpdateCartExpectation specifies expectation struct of the Repository.UpdateCart
type RepositoryMockUpdateCartExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockUpdateCartParams
	paramPtrs *RepositoryMockUpdateCartParamPtrs

	Counter uint64
}

// RepositoryMockUpdateCartParams contains parameters of the Repository.UpdateCart
type RepositoryMockUpdateCartParams struct {
	ctx  context.Context
	cart *model.Cart
}

// RepositoryMockUpdateCartParamPtrs contains pointers to parameters of the Repository.UpdateCart
type RepositoryMockUpdateCartParamPtrs struct {
	ctx  *context.Context
	cart **model.Cart
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateCart *mRepositoryMockUpdateCart) Optional() *mRepositoryMockUpdateCart {
	mmUpdateCart.optional = true
	return mmUpdateCart
}

// Expect sets up expected params for Repository.UpdateCart
func (mmUpdateCart *mRepositoryMockUpdateCart) Expect(ctx context.Context, cart *model.Cart) *mRepositoryMockUpdateCart {
	if mmUpdateCart.mock.funcUpdateCart != nil {
		mmUpdateCart.mock.t.Fatalf("RepositoryMock.UpdateCart mock is already set by Set")
	}

	if mmUpdateCart.defaultExpectation == nil {
		mmUpdateCart.defaultExpectation = &RepositoryMockUpdateCartExpectation{}
	}

	if mmUpdateCart.defaultExpectation.paramPtrs != nil {
		mmUpdateCart.mock.t.Fatalf("RepositoryMock.UpdateCart mock is already set by ExpectParams functions")
	}

	mmUpdateCart.defaultExpectation.params = &RepositoryMockUpdateCartParams{ctx, cart}
	for _, e := range mmUpdateCart.expectations {
		if minimock.Equal(e.params, mmUpdateCart.defaultExpectation.params) {
			mmUpdateCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCart.defaultExpectation.params)
		}
	}

	return mmUpdateCart
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateCart
func (mmUpdateCart *mRepositoryMockUpdateCart) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateCart {
	if mmUpdateCart.mock.funcUpdateCart != nil {
		mmUpdateCart.mock.t.Fatalf("RepositoryMock.UpdateCart mock is already set by Set")
	}

	if mmUpdateCart.defaultExpectation == nil {
		mmUpdateCart.defaultExpectation = &RepositoryMockUpdateCartExpectation{}
	}

	if mmUpdateCart.defaultExpectation.params != nil {
		mmUpdateCart.mock.t.Fatalf("RepositoryMock.UpdateCart mock is already set by Expect")
	}

	if mmUpdateCart.defaultExpectation.paramPtrs == nil {
		mmUpdateCart.defaultExpectation.paramPtrs = &RepositoryMockUpdateCartParamPtrs{}
	}
	mmUpdateCart.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateCart
}

// ExpectCartParam2 sets up expected param cart for Repository.UpdateCart
func (mmUpdateCart *mRepositoryMockUpdateCart) ExpectCartParam2(cart *model.Cart) *mRepositoryMockUpdateCart {
	if mmUpdateCart.mock.funcUpdateCart != nil {
		mmUpdateCart.mock.t.Fatalf("RepositoryMock.UpdateCart mock is already set by Set")
	}

	if mmUpdateCart.defaultExpectation == nil {
		mmUpdateCart.defaultExpectation = &RepositoryMockUpdateCartExpectation{}
	}

	if mmUpdateCart.defaultExpectation.params != nil {
		mmUpdateCart.mock.t.Fatalf("RepositoryMock.UpdateCart mock is already set by Expect")
	}

	if mmUpdateCart.defaultExpectation.paramPtrs == nil {
		mmUpdateCart.defaultExpectation.paramPtrs = &RepositoryMockUpdateCartParamPtrs{}
	}
	mmUpdateCart.defaultExpectation.paramPtrs.cart = &cart

	return mmUpdateCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateCart
func (mmUpdateCart *mRepositoryMockUpdateCart) Inspect(f func(ctx context.Context, cart *model.Cart)) *mRepositoryMockUpdateCart {
	if mmUpdateCart.mock.inspectFuncUpdateCart != nil {
		mmUpdateCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateCart")
	}

	mmUpdateCart.mock.inspectFuncUpdateCart = f

	return mmUpdateCart
}

// Return sets up results that will be returned by Repository.UpdateCart
func (mmUpdateCart *mRepositoryMockUpdateCart) Return() *RepositoryMock {
	if mmUpdateCart.mock.funcUpdateCart != nil {
		mmUpdateCart.mock.t.Fatalf("RepositoryMock.UpdateCart mock is already set by Set")
	}

	if mmUpdateCart.defaultExpectation == nil {
		mmUpdateCart.defaultExpectation = &RepositoryMockUpdateCartExpectation{mock: mmUpdateCart.mock}
	}

	return mmUpdateCart.mock
}

// Set uses given function f to mock the Repository.UpdateCart method
func (mmUpdateCart *mRepositoryMockUpdateCart) Set(f func(ctx context.Context, cart *model.Cart)) *RepositoryMock {
	if mmUpdateCart.defaultExpectation != nil {
		mmUpdateCart.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateCart method")
	}

	if len(mmUpdateCart.expectations) > 0 {
		mmUpdateCart.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateCart method")
	}

	mmUpdateCart.mock.funcUpdateCart = f
	return mmUpdateCart.mock
}

// Times sets number of times Repository.UpdateCart should be invoked
func (mmUpdateCart *mRepositoryMockUpdateCart) Times(n uint64) *mRepositoryMockUpdateCart {
	if n == 0 {
		mmUpdateCart.mock.t.Fatalf("Times of RepositoryMock.UpdateCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateCart.expectedInvocations, n)
	return mmUpdateCart
}

func (mmUpdateCart *mRepositoryMockUpdateCart) invocationsDone() bool {
	if len(mmUpdateCart.expectations) == 0 && mmUpdateCart.defaultExpectation == nil && mmUpdateCart.mock.funcUpdateCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateCart.mock.afterUpdateCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateCart implements cart.Repository
func (mmUpdateCart *RepositoryMock) UpdateCart(ctx context.Context, cart *model.Cart) {
	mm_atomic.AddUint64(&mmUpdateCart.beforeUpdateCartCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCart.afterUpdateCartCounter, 1)

	if mmUpdateCart.inspectFuncUpdateCart != nil {
		mmUpdateCart.inspectFuncUpdateCart(ctx, cart)
	}

	mm_params := RepositoryMockUpdateCartParams{ctx, cart}

	// Record call args
	mmUpdateCart.UpdateCartMock.mutex.Lock()
	mmUpdateCart.UpdateCartMock.callArgs = append(mmUpdateCart.UpdateCartMock.callArgs, &mm_params)
	mmUpdateCart.UpdateCartMock.mutex.Unlock()

	for _, e := range mmUpdateCart.UpdateCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmUpdateCart.UpdateCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCart.UpdateCartMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCart.UpdateCartMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateCart.UpdateCartMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateCartParams{ctx, cart}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateCart.t.Errorf("RepositoryMock.UpdateCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cart != nil && !minimock.Equal(*mm_want_ptrs.cart, mm_got.cart) {
				mmUpdateCart.t.Errorf("RepositoryMock.UpdateCart got unexpected parameter cart, want: %#v, got: %#v%s\n", *mm_want_ptrs.cart, mm_got.cart, minimock.Diff(*mm_want_ptrs.cart, mm_got.cart))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCart.t.Errorf("RepositoryMock.UpdateCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmUpdateCart.funcUpdateCart != nil {
		mmUpdateCart.funcUpdateCart(ctx, cart)
		return
	}
	mmUpdateCart.t.Fatalf("Unexpected call to RepositoryMock.UpdateCart. %v %v", ctx, cart)

}

// UpdateCartAfterCounter returns a count of finished RepositoryMock.UpdateCart invocations
func (mmUpdateCart *RepositoryMock) UpdateCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCart.afterUpdateCartCounter)
}

// UpdateCartBeforeCounter returns a count of RepositoryMock.UpdateCart invocations
func (mmUpdateCart *RepositoryMock) UpdateCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCart.beforeUpdateCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCart *mRepositoryMockUpdateCart) Calls() []*RepositoryMockUpdateCartParams {
	mmUpdateCart.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateCartParams, len(mmUpdateCart.callArgs))
	copy(argCopy, mmUpdateCart.callArgs)

	mmUpdateCart.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCartDone returns true if the count of the UpdateCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateCartDone() bool {
	if m.UpdateCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateCartMock.invocationsDone()
}

// MinimockUpdateCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateCartInspect() {
	for _, e := range m.UpdateCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateCart with params: %#v", *e.params)
		}
	}

	afterUpdateCartCounter := mm_atomic.LoadUint64(&m.afterUpdateCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCartMock.defaultExpectation != nil && afterUpdateCartCounter < 1 {
		if m.UpdateCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateCart")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateCart with params: %#v", *m.UpdateCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCart != nil && afterUpdateCartCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateCart")
	}

	if !m.UpdateCartMock.invocationsDone() && afterUpdateCartCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateCart but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateCartMock.expectedInvocations), afterUpdateCartCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetCartInspect()

			m.MinimockHasCartInspect()

			m.MinimockRemoveCartInspect()

			m.MinimockUpdateCartInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetCartDone() &&
		m.MinimockHasCartDone() &&
		m.MinimockRemoveCartDone() &&
		m.MinimockUpdateCartDone()
}
